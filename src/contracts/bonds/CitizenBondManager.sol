// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "./IBondContract.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Address.sol";

// TODO - Receiver functionality
// TODO - Direct Ether receive and default non-present function call checks
// TODO - events
// TODO - getters
contract CitizenBondManager is Pausable, AccessControl {
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    using Counters for Counters.Counter;
    using Address for address;

    // Counters let us easy iterate over Ids {from 0 to current}.
    Counters.Counter private _poolIdCounter;
    Counters.Counter private _categoryIdCounter;

    // Structure to save Category (Health, Enviornment) info etc.
    struct Category {
        string name;
        uint256 categoryId;
        bool isExist;
        // All pools in this category
        uint256[] poolIds;
    }

    // Structure to store state of pools
    struct Pool {
        bool isActive;
        bool isExist;
        uint256 poolId;
        uint256 lastBondIssuedId; // Since the tokenIds of NFTs are autogenerated - this also serves as total bonds issued per pool
        uint256 creationTime;
        uint256 categoryId;
        // TODO - store IBondContract here? or like this - james
        address poolContractAddress;
    }

    mapping(uint256 => Category) private _categories;
    mapping(uint256 => Pool) private _pools;

    function purchaseBond(uint256 poolId) external payable whenNotPaused {
        require(msg.value > 0, "Cannot purchase 0 ether bonds");

        Pool storage pool = _pools[poolId];
        require(pool.isExist, "Pool doesn't exist");
        require(pool.isActive, "Pool Inactive");

        IBondContract poolContract = IBondContract(pool.poolContractAddress);

        if (poolContract.isPoolExpired()) revert("Pool Expired");

        pool.lastBondIssuedId = poolContract.mint{value: msg.value}(msg.sender);
    }

    function addPool(uint256 categoryId, address poolAddress)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(poolAddress != address(0), "Pool Address can't be black hole");
        require(
            address(poolAddress).isContract(),
            "Pool Address must be a contract"
        );
        require(_categories[categoryId].isExist, "Category does not exist");

        uint256 poolId = _poolIdCounter.current();

        Pool memory pool;
        pool.isActive = true;
        pool.isExist = true;
        pool.poolId = poolId;
        pool.creationTime = block.timestamp;
        pool.categoryId = categoryId;
        pool.poolContractAddress = poolAddress;
        _categories[categoryId].poolIds.push(poolId);

        _poolIdCounter.increment();

        _pools[poolId] = pool;
    }

    function addCategory(string memory name)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        uint256 categoryId = _categoryIdCounter.current();

        Category memory category;
        category.name = name;
        category.categoryId = categoryId;
        category.isExist = true;
        _categories[categoryId] = category;

        _categoryIdCounter.increment();
    }

    function getCategories() public view returns (Category[] memory) {
        Category[] memory categories;
        for (uint16 i = 0; i < _categoryIdCounter.current(); i++) {
            if (_categories[i].isExist) {
                Category memory category = _categories[i];
                categories[i] = category;
            }
        }
        return categories;
    }

    function getPools() public view returns (Pool[] memory) {
        Pool[] memory pools;
        for (uint16 i = 0; i < _poolIdCounter.current(); i++) {
            if (_pools[i].isExist) {
                Pool memory pool = _pools[i];
                pools[i] = pool;
            }
        }
        return pools;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
    }

    function pause() public onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }
}
